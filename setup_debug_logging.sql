-- Create Debug Logs Table
CREATE TABLE IF NOT EXISTS debug_logs (
    id bigint generated by default as identity primary key,
    message text,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Modify active_org_id to LOG headers
CREATE OR REPLACE FUNCTION public.active_org_id()
RETURNS bigint
LANGUAGE plpgsql
STABLE SECURITY DEFINER
AS $$
DECLARE
    header_org_id text;
    jwt_org_id text;
    all_headers text;
BEGIN
    all_headers := current_setting('request.headers', true);
    
    -- Log headers (LIMIT to avoid massive logs, just for debug)
    -- We use autonomous transaction via dblink or just simple insert if not read-only
    -- Since this is STABLE, we cannot INSERT directly if called in SELECT...
    -- BUT we can if we make it VOLATILE. For debug, let's make it VOLATILE temporarily.
    
    -- For now, let's just RAISE NOTICE to logs if we can't INSERT
    -- Or better, let's rely on the fact that force_tenant_id trigger CALLS this.
    -- The trigger IS volatile? No, it's a trigger function.
    
    -- Actually, simpler: Checking headers via SELECT from console.
    
    -- 1. Try Custom Header (x-organization-id) from Frontend
    header_org_id := current_setting('request.headers', true)::json ->> 'x-organization-id';
    
    -- Validate and Return
    IF header_org_id IS NOT NULL AND header_org_id ~ '^[0-9]+$' THEN
        RETURN header_org_id::bigint;
    END IF;

    -- 2. Try JWT Claim (Fallback)
    jwt_org_id := (auth.jwt() -> 'app_metadata' ->> 'active_organization_id');
    IF jwt_org_id IS NOT NULL AND jwt_org_id <> '' THEN
        RETURN jwt_org_id::bigint;
    END IF;

    RETURN NULL;
END;
$$;

-- Create a dedicated logging function we can call via RPC to inspecting headers
CREATE OR REPLACE FUNCTION debug_header_check()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO debug_logs (message) VALUES (current_setting('request.headers', true));
    RETURN current_setting('request.headers', true)::jsonb;
END;
$$;
